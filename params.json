{
  "name": "KSpec",
  "tagline": "Kotlin Specification Framework",
  "body": "# KSpec \r\n[![Bintray](https://img.shields.io/bintray/v/raniejade/maven/kspec.svg)](https://bintray.com/raniejade/maven/kspec/_latestVersion) [![Build Status](https://travis-ci.org/raniejade/kspec.svg?branch=master)](https://travis-ci.org/raniejade/kspec) [![codecov.io](https://codecov.io/github/raniejade/kspec/coverage.svg?branch=master)](https://codecov.io/github/raniejade/kspec?branch=master)\r\n\r\nSpecifications for Kotlin.\r\n\r\n## Basic Structure\r\n```kotlin\r\nclass TheMostAmazingAnimalSpec: KSpec() {\r\n    override fun spec() {\r\n        describe(\"the most amazing animal in the universe\") {\r\n            val animal = GetMostAmazingAnimal()\r\n            it(\"should be a panda\") {\r\n                assertThat(animal.type, equalTo(\"panda\"))\r\n            }\r\n            \r\n            context(\"not a panda\") {\r\n                it(\"nope, not going to accept it\") {\r\n                    assertThat({\r\n                        assertThat(animal.type, not(equalTo(\"panda\")))\r\n                    }, thrown(EndOfTheWorldException::class))\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Context\r\nKSpec is heavily inspired by [RSpec](http://rspec.info/), `Context` is synonymous to RSpec's scopes.\r\n\r\n### Example\r\nThe test method in JUnit and created using `it`.\r\n\r\n### ExampleGroup\r\nGroups similar examples together (they might be testing the same `Subject` - more on this later) and is created by using `describe` or `context`. Be cautious in placing logic code in them as they are eagerly evaluated\r\n\r\n## Fixtures\r\nKSpec provides `before`, `beforeEach`, `afterEach` and `after` callbacks for each context.\r\n\r\n## Subject\r\nJust like RSpec, KSpec also support subjects.\r\n```kotlin\r\nclass TheMostAmazingAnimalSpec: KSpec() {\r\n    override fun spec() {\r\n        describe(\"the most amazing animal in the universe\") {\r\n            subject {\r\n                return@subject GetMostAmazingAnimal();\r\n            }\r\n            \r\n            it(\"should be a panda\") {\r\n                assertThat(subject.type, equalTo(\"panda\"))\r\n            }\r\n            \r\n            context(\"not a panda\") {\r\n                it(\"nope, not going to accept it\") {\r\n                    assertThat({\r\n                        assertThat(subject.type, not(equalTo(\"panda\")))\r\n                    }, thrown(EndOfTheWorldException::class))\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Shared Examples\r\nSometimes it's convenient to reuse examples - like testing a subclass.\r\n```kotlin\r\nclass CalculatorSpec: KSpec() {\r\n    override fun spec() {\r\n        describe(Calculator::class) {\r\n            itBehavesLike(calculator())\r\n        }\r\n    }\r\n    \r\n    companion object {\r\n        fun calculator() = sharedExample<Calculator> {\r\n            describe(\"add\") {\r\n                it(\"1 + 1 = 2\") {\r\n                    assertThat(subject.add(1, 1), equalTo(2))\r\n                }\r\n            }\r\n            ...\r\n        }\r\n    }\r\n}\r\n\r\nclass AdvancedCalculatorSpec: KSpec() {\r\n    override fun spec() {\r\n        describe(AdvancedCalculator::class) {\r\n            itBehavesLike(CalculatorSpec.calculator())\r\n        }\r\n    }\r\n}\r\n```\r\n## Pending\r\nYou can write specs in advance, KSpec will ignore them during execution.\r\n```kotlin\r\noverride fun spec() {\r\n    xdescribe(\"a pending group\") {\r\n        it(\"won't be executed\") { }\r\n    }\r\n\r\n    xcontext(\"another pending group\", \"some reason\")\r\n\r\n    xit(\"a pending example\") { }\r\n}\r\n```\r\n\r\n## Focused\r\nKSpec supports focusing execution only on several contexts. Use `fdescribe` and `fcontext` to create a focused group, and `fit` to create a focused example. KSpec will only run focused contexts if there are any, othewise it will run everything.\r\n\r\n## Tagging\r\nTODO\r\n\r\n## Filters\r\nThis allows to control which contexts to run. It can be configured per spec (by overriding `configure`) or by using *Shared Configurations*.\r\n```kotlin\r\nclass SomeSpec: KSpec() {\r\n    override fun configure(config: KSpecConfig) {\r\n       // config.filter.<filter> = tags\r\n    }\r\n}\r\n```\r\n\r\n### include\r\nOnly include contexts having at least one of the `tags` specified.\r\n\r\n### exclude\r\nExclude any contexts having at least one of the `tags` specified.\r\n\r\n### matching\r\nSimilar to the *include filter*, the only difference is that if there is no match run everything.\r\n\r\n## Shared Configurations\r\nDeclare shared configurations by extending `Configuration` and apply it to a spec via `@Configurations`.\r\n```kotlin\r\nclass SharedConfiguration: Configuration {\r\n    override fun apply(config: KSpecConfig) {\r\n        ...\r\n    }\r\n}\r\n\r\nclass AnotherConfiguration: Configuration {\r\n    override fun apply(config: KSpecConfig) {\r\n        ...\r\n    }\r\n}\r\n\r\n// use it\r\n@Configurations(\r\n    SharedConfiguration::class,\r\n    AnotherConfiguration::class\r\n)\r\nclass SomeSpec: KSpec() {\r\n    ...\r\n}\r\n```\r\n\r\n## Runner\r\nCurrently only a JUnit 4 Runner is provided. Make sure to annotate your test classes with `@RunWith(JUnitKSpecRunner)`.\r\n\r\n\r\n## Usage\r\n### Gradle\r\n```gradle\r\nrepositories {\r\n    jcenter()\r\n}\r\n\r\ndependencies {\r\n    testCompile \"io.polymorphicpanda.kspec:kspec-core:<kspec-version>\"\r\n    testCompile \"io.polymorphicpanda.kspec:kspec-junit-runner:<kspec-version>\"\r\n}\r\n```\r\n\r\nSnapshot versions are available at http://oss.jfrog.org/artifactory/oss-snapshot-local/\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}